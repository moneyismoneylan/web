import pytest
import types
import asyncio
import base64
from unittest.mock import AsyncMock
from sqli_hunter.exploiter import Exploiter


@pytest.mark.asyncio
async def test_low_and_slow_channels(mocker):
    # This test now uses the new simulated methods, not placeholder data
    exploiter = Exploiter(types.SimpleNamespace())
    exploiter.config = {
        "doh": {"enabled": True, "domain": "exfil.com"},
    }
    # Mock all network calls
    mocker.patch("dns.asyncresolver.Resolver", return_value=AsyncMock())
    mocker.patch("sqli_hunter.exploiter.serve", new_callable=AsyncMock)
    mocker.patch("sqli_hunter.exploiter.connect", new_callable=AsyncMock)
    mocker.patch("websockets.serve", new_callable=AsyncMock)
    mocker.patch("websockets.connect", new_callable=AsyncMock)

    vuln = {
        'url': 'http://example.com',
        'method': 'GET',
        'parameter': 'id'
    }

    # We can't easily test the result of the mocked calls,
    # but we can test that they don't crash.
    await exploiter.extract_data_doh(None, vuln, 'k0')
    await exploiter.extract_data_quic(None, vuln, 'k2')
    await exploiter.extract_data_ws(None, vuln, 'k3')

    # Since the methods are heavily mocked, we just assert they run without error.
    # The new test in test_new_features.py handles more detailed checks.
    assert True
