# -*- coding: utf-8 -*-
"""
WAF Fingerprinting Engine.

This module is responsible for identifying the Web Application Firewall
protecting the target application. It uses a combination of response header,
status code, and body content analysis.
"""
from playwright.async_api import BrowserContext, Error
import re
import asyncio
import cloudscraper
from urllib.parse import urlparse

# A database of WAF signatures. This can be expanded.
WAF_SIGNATURES = {
    "Cloudflare": {
        "headers": {"Server": "cloudflare"},
        "cookies": ["__cfduid", "cf_bm"],
        "body": r'cloudflare\.com|ray id|checking your browser|challenge-platform'
    },
    "Akamai": {
        "headers": {"Server": "AkamaiGHost", "X-Akamai-Transformed": ".*"},
        "cookies": [],
        "body": r'The requested URL was rejected'
    },
    "Imperva (Incapsula)": {
        "headers": {},
        "cookies": ["incap_ses_", "visid_incap_"],
        "body": r'incapsula|powered by imperva'
    },
    "AWS WAF": {
        "headers": {"Server": "awselb/2.0"},
        "cookies": ["AWSALB"],
        "body": r'<h1>403 forbidden</h1>'
    },
    "Sucuri": {
        "headers": {"Server": "Sucuri/Cloudproxy"},
        "cookies": [],
        "body": r'sucuri_cloudproxy_waf'
    },
    "Wordfence": {
        "headers": {},
        "cookies": ["wfvt_"],
        "body": r'generated by wordfence'
    },
    "F5 ASM": {
        "headers": {"Server": "BigIP|F5"},
        "cookies": ["TS"],
        "body": [
            r"the requested url was rejected",
            r"please consult with your administrator"
        ]
    },
    "Barracuda": {
        "headers": {},
        "cookies": [
            "BNI__BARRACUDA_LB_COOKIE",
            "BNI_persistence",
            "BNIS_",
            "BNES_",
            "barra_counter_session"
        ],
        "body": r"barracuda\.networks"
    },
    "ModSecurity": {
        "headers": {"Server": r"(mod_security|Mod_Security|NOYB)"},
        "cookies": [],
        "body": r"This error was generated by Mod.?Security|Protected by Mod.?Security|mod.security.rules triggered"
    }
}

MALICIOUS_PROBE_URL = "/?s=<script>alert('XSS')</script>"

class WafDetector:
    """
    Detects a WAF by sending a malicious probe and checking the response
    against a known set of WAF signatures.
    """
    def __init__(self, browser_context: BrowserContext, scraper: cloudscraper.CloudScraper):
        self.context = browser_context
        self.scraper = scraper

    def _check_signatures_headless(self, response, cookies) -> str | None:
        """Compares response headers, cookies, and body against the WAF signature DB using headless response."""
        if not response:
            return None

        headers = {k.lower(): v for k, v in response.headers.items()}
        cookie_names = {c.name for c in cookies}
        body = response.text

        for waf_name, signatures in WAF_SIGNATURES.items():
            matches = 0

            # Check headers
            for header, pattern in signatures.get("headers", {}).items():
                header_lower = header.lower()
                if header_lower in headers and re.search(pattern, headers[header_lower], re.IGNORECASE):
                    matches += 1
                    break

            # Check cookies
            for cookie_pattern in signatures.get("cookies", []):
                if any(c.startswith(cookie_pattern) for c in cookie_names):
                    matches += 1
                    break

            # Check body
            body_patterns = signatures.get("body")
            if body_patterns:
                if isinstance(body_patterns, str):
                    body_patterns = [body_patterns]
                if all(re.search(p, body, re.IGNORECASE) for p in body_patterns):
                    matches += 1

            if matches >= signatures.get("min_matches", 2):
                return waf_name
        return None

    async def _transfer_cookies_to_browser_context(self, scraper: cloudscraper.CloudScraper, url: str):
        """Transfers cookies from cloudscraper to the Playwright browser context."""
        parsed_url = urlparse(url)
        cookies_to_add = []
        for cookie in scraper.cookies:
            cookies_to_add.append({
                "name": cookie.name,
                "value": cookie.value,
                "domain": cookie.domain or parsed_url.netloc,
                "path": cookie.path or "/",
                "expires": cookie.expires,
                "httpOnly": cookie.has_nonstandard_attr('HttpOnly'),
                "secure": cookie.secure,
            })
        if cookies_to_add:
            await self.context.add_cookies(cookies_to_add)

    async def check_waf(self, base_url: str) -> str | None:
        """
        Probes the target to identify the WAF using a headless, JS-enabled client.

        :param base_url: The base URL of the target application.
        :return: The name of the detected WAF or None.
        """
        print("[*] Starting WAF fingerprinting...")

        # First, check the base response without a malicious probe
        try:
            response = await asyncio.to_thread(self.scraper.get, base_url, timeout=15)
            await self._transfer_cookies_to_browser_context(self.scraper, base_url)

            waf_name = self._check_signatures_headless(response, self.scraper.cookies)
            if waf_name:
                print(f"[+] WAF Detected on initial request: {waf_name}")
                return waf_name
        except Exception:
            pass # Ignore initial request failure

        # If no WAF found, send a malicious probe to trigger it
        probe_url = base_url.rstrip('/') + MALICIOUS_PROBE_URL
        try:
            response = await asyncio.to_thread(self.scraper.get, probe_url, timeout=15)
            await self._transfer_cookies_to_browser_context(self.scraper, probe_url)

            waf_name = self._check_signatures_headless(response, self.scraper.cookies)
            if waf_name:
                print(f"[+] WAF Detected after malicious probe: {waf_name}")
                return waf_name
        except Exception:
            # A more advanced implementation could analyze the error.
            pass

        print("[-] No specific WAF detected.")
        return None
