# -*- coding: utf-8 -*-
"""
WAF Fingerprinting Engine.

This module is responsible for identifying the Web Application Firewall
protecting the target application. It uses a combination of response header,
status code, and body content analysis.
"""
from playwright.async_api import BrowserContext, Error, Response
import re

# A database of WAF signatures. This can be expanded.
WAF_SIGNATURES = {
    "Cloudflare": {
        "headers": {"Server": "cloudflare"},
        "cookies": ["__cfduid", "cf_bm"],
        "body": r'cloudflare\.com|ray id|checking your browser'
    },
    "Akamai": {
        "headers": {"Server": "AkamaiGHost", "X-Akamai-Transformed": ".*"},
        "cookies": [],
        "body": r'The requested URL was rejected'
    },
    "Imperva (Incapsula)": {
        "headers": {},
        "cookies": ["incap_ses_", "visid_incap_"],
        "body": r'incapsula|powered by imperva'
    },
    "AWS WAF": {
        "headers": {"Server": "awselb/2.0"},
        "cookies": ["AWSALB"],
        "body": r'<h1>403 forbidden</h1>'
    },
    "Sucuri": {
        "headers": {"Server": "Sucuri/Cloudproxy"},
        "cookies": [],
        "body": r'sucuri_cloudproxy_waf'
    },
    "Wordfence": {
        "headers": {},
        "cookies": ["wfvt_"],
        "body": r'generated by wordfence'
    }
}

MALICIOUS_PROBE_URL = "/?s=<script>alert('XSS')</script>"

class WafDetector:
    """
    Detects a WAF by sending a malicious probe and checking the response
    against a known set of WAF signatures.
    """
    def __init__(self, browser_context: BrowserContext):
        self.context = browser_context

    async def _check_signatures(self, response: Response) -> str | None:
        """Compares response headers, cookies, and body against the WAF signature DB."""
        if not response:
            return None

        headers = {k.lower(): v for k, v in response.headers.items()}
        cookies = {c['name'] for c in await self.context.cookies(response.url)}
        try:
            body = await response.text()
        except Error:
            body = ""

        for waf_name, signatures in WAF_SIGNATURES.items():
            # Check headers
            for header, pattern in signatures.get("headers", {}).items():
                if header in headers and re.search(pattern, headers[header], re.IGNORECASE):
                    return waf_name
            # Check cookies
            for cookie_name in signatures.get("cookies", []):
                if any(cookie.startswith(cookie_name) for cookie in cookies):
                    return waf_name
            # Check body
            if re.search(signatures.get("body", ""), body, re.IGNORECASE):
                return waf_name
        return None

    async def check_waf(self, base_url: str) -> str | None:
        """
        Probes the target to identify the WAF.

        :param base_url: The base URL of the target application.
        :return: The name of the detected WAF or None.
        """
        page = await self.context.new_page()
        print("[*] Starting WAF fingerprinting...")
        try:
            # First, check the base response without a malicious probe
            try:
                response = await page.goto(base_url, wait_until="domcontentloaded", timeout=10000)
                waf_name = await self._check_signatures(response)
                if waf_name:
                    print(f"[+] WAF Detected on initial request: {waf_name}")
                    return waf_name
            except Error:
                pass # Ignore initial request failure

            # If no WAF found, send a malicious probe to trigger it
            probe_url = base_url.rstrip('/') + MALICIOUS_PROBE_URL
            try:
                response = await page.goto(probe_url, wait_until="domcontentloaded", timeout=10000)
                waf_name = await self._check_signatures(response)
                if waf_name:
                    print(f"[+] WAF Detected after malicious probe: {waf_name}")
                    return waf_name
            except Error:
                # Sometimes the request itself fails, which is a signal.
                # A more advanced implementation could analyze the error.
                pass

        finally:
            await page.close()

        print("[-] No specific WAF detected.")
        return None
